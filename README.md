The Gaming Room Client and Their Software Requirements
The Gaming Room was the client, and they wanted a software design for their game Draw It or Lose It. The goal was to expand the game beyond Android so it could run across multiple platforms and devices. 
Because the game relies on quickly displaying and managing large image files, the design needed to address fast image handling, efficient memory and storage use, support for a distributed/client-server environment, and strong security controls to protect users and game data.

What I Did Well in Developing the Documentation
A major strength of my design document was how thoroughly it broke the system down into clear, manageable sections. 
I focused on connecting the client’s requirements to specific technical considerations—especially around performance (memory/storage planning), scalability (distributed design), and security. 
This helped turn the client’s goals into a structured plan that a development team could realistically implement.

How the Design Document Helped When Developing the Code
Working through the design document made the coding process more organized and less uncertain. 
By defining requirements early and thinking through architecture choices ahead of time, I had a clearer path for implementation. 
The design document worked like a checklist and reference guide, reducing guesswork and helping prevent rework caused by missing requirements or unclear design decisions.

What I Would Revise and How I Would Improve It
If I could revise one part of the documentation, I would strengthen the security section. While it covered key concepts, 
I would improve it by including more modern, real-world practices such as stronger authentication options, more detailed encryption and key-management planning, and a clearer explanation of risk mitigation strategies based on current threat trends.

How I Interpreted User Needs and Why That Matters
I translated user needs into design decisions by focusing on what would matter most to players: a smooth experience, fast image loading, reliable gameplay, and safe handling of user data. 
Considering user needs is critical because software success depends on usability and trust. 
Even a technically “correct” solution can fail if it performs poorly, frustrates users, or does not meet expectations across different devices and platforms.

My Approach to Designing Software and Strategies for the Future
My approach followed a structured process: first understanding requirements, then selecting an architecture that supports scalability and cross-platform compatibility, and finally evaluating platform considerations like performance and security. 
In the future, I would strengthen this process by using strategies such as iterative design, prototyping early, incorporating user feedback cycles, and planning around CI/CD practices to support steady improvement and reliable releases. 
These techniques would help me analyze similar projects more efficiently and produce designs that are both practical and user-focused.
